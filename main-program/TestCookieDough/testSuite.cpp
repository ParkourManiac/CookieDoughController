// THIS FILE WAS AUTOGENERATED BY FILE generateTestSuite.py
#include "testSuite.h" 
#include "test.h"

#include "Fakes/Arduino.h"
#include "Fakes/EEPROM.h"

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wcast-qual"
#pragma GCC diagnostic ignored "-Wold-style-cast"
int digitalRead_return;
unsigned int digitalRead_invocations = 0;
uint8_t digitalRead_param_pin;
int digitalRead(uint8_t pin)
{
	digitalRead_invocations++;
	digitalRead_param_pin = (uint8_t)pin;

	return digitalRead_return;
}

unsigned int pinMode_invocations = 0;
uint8_t pinMode_param_pin;
std::vector<uint8_t> pinMode_param_pin_v;
uint8_t pinMode_param_mode;
std::vector<uint8_t> pinMode_param_mode_v;
void pinMode(uint8_t pin, uint8_t mode)
{
	pinMode_invocations++;
	pinMode_param_pin = (uint8_t)pin;
	pinMode_param_pin_v.push_back((uint8_t)pin);
	pinMode_param_mode = (uint8_t)mode;
	pinMode_param_mode_v.push_back((uint8_t)mode);

}

unsigned long millis_return;
unsigned int millis_invocations = 0;
unsigned long millis()
{
	millis_invocations++;

	return millis_return;
}

unsigned int digitalWrite_invocations = 0;
uint8_t digitalWrite_param_pin;
uint8_t digitalWrite_param_val;
void digitalWrite(uint8_t pin, uint8_t val)
{
	digitalWrite_invocations++;
	digitalWrite_param_pin = (uint8_t)pin;
	digitalWrite_param_val = (uint8_t)val;

}

unsigned int delay_invocations = 0;
unsigned long delay_param_ms;
void delay(unsigned long ms)
{
	delay_invocations++;
	delay_param_ms = (unsigned long)ms;

}

double pow_return;
unsigned int pow_invocations = 0;
double pow_param_base;
double pow_param_exponent;
double pow(double base, double exponent)
{
	pow_invocations++;
	pow_param_base = (double)base;
	pow_param_exponent = (double)exponent;

	return pow_return;
}

size_t Serial__print_return_o1;
unsigned int Serial__print_invocations_o1 = 0;
char * Serial__print_param_a_o1;
size_t Serial_::print(const char * a)
{
	Serial__print_invocations_o1++;
	Serial__print_param_a_o1 = (char *)a;

	return Serial__print_return_o1;
}

size_t Serial__print_return_o2;
unsigned int Serial__print_invocations_o2 = 0;
char Serial__print_param_a_o2;
size_t Serial_::print(char a)
{
	Serial__print_invocations_o2++;
	Serial__print_param_a_o2 = (char)a;

	return Serial__print_return_o2;
}

size_t Serial__print_return_o3;
unsigned int Serial__print_invocations_o3 = 0;
unsigned char Serial__print_param_a_o3;
int Serial__print_param_b_o3;
size_t Serial_::print(unsigned char a, int b)
{
	Serial__print_invocations_o3++;
	Serial__print_param_a_o3 = (unsigned char)a;
	Serial__print_param_b_o3 = (int)b;

	return Serial__print_return_o3;
}

size_t Serial__print_return_o4;
unsigned int Serial__print_invocations_o4 = 0;
int Serial__print_param_a_o4;
int Serial__print_param_b_o4;
size_t Serial_::print(int a, int b)
{
	Serial__print_invocations_o4++;
	Serial__print_param_a_o4 = (int)a;
	Serial__print_param_b_o4 = (int)b;

	return Serial__print_return_o4;
}

size_t Serial__print_return_o5;
unsigned int Serial__print_invocations_o5 = 0;
unsigned int Serial__print_param_a_o5;
int Serial__print_param_b_o5;
size_t Serial_::print(unsigned int a, int b)
{
	Serial__print_invocations_o5++;
	Serial__print_param_a_o5 = (unsigned int)a;
	Serial__print_param_b_o5 = (int)b;

	return Serial__print_return_o5;
}

size_t Serial__print_return_o6;
unsigned int Serial__print_invocations_o6 = 0;
long Serial__print_param_a_o6;
int Serial__print_param_b_o6;
size_t Serial_::print(long a, int b)
{
	Serial__print_invocations_o6++;
	Serial__print_param_a_o6 = (long)a;
	Serial__print_param_b_o6 = (int)b;

	return Serial__print_return_o6;
}

size_t Serial__print_return_o7;
unsigned int Serial__print_invocations_o7 = 0;
unsigned long Serial__print_param_a_o7;
int Serial__print_param_b_o7;
size_t Serial_::print(unsigned long a, int b)
{
	Serial__print_invocations_o7++;
	Serial__print_param_a_o7 = (unsigned long)a;
	Serial__print_param_b_o7 = (int)b;

	return Serial__print_return_o7;
}

size_t Serial__print_return_o8;
unsigned int Serial__print_invocations_o8 = 0;
double Serial__print_param_a_o8;
int Serial__print_param_b_o8;
size_t Serial_::print(double a, int b)
{
	Serial__print_invocations_o8++;
	Serial__print_param_a_o8 = (double)a;
	Serial__print_param_b_o8 = (int)b;

	return Serial__print_return_o8;
}

size_t Serial__println_return_o1;
unsigned int Serial__println_invocations_o1 = 0;
char * Serial__println_param_a_o1;
size_t Serial_::println(const char * a)
{
	Serial__println_invocations_o1++;
	Serial__println_param_a_o1 = (char *)a;

	return Serial__println_return_o1;
}

size_t Serial__println_return_o2;
unsigned int Serial__println_invocations_o2 = 0;
char Serial__println_param_b_o2;
size_t Serial_::println(char b)
{
	Serial__println_invocations_o2++;
	Serial__println_param_b_o2 = (char)b;

	return Serial__println_return_o2;
}

size_t Serial__println_return_o3;
unsigned int Serial__println_invocations_o3 = 0;
unsigned char Serial__println_param_a_o3;
int Serial__println_param_b_o3;
size_t Serial_::println(unsigned char a, int b)
{
	Serial__println_invocations_o3++;
	Serial__println_param_a_o3 = (unsigned char)a;
	Serial__println_param_b_o3 = (int)b;

	return Serial__println_return_o3;
}

size_t Serial__println_return_o4;
unsigned int Serial__println_invocations_o4 = 0;
int Serial__println_param_a_o4;
int Serial__println_param_b_o4;
size_t Serial_::println(int a, int b)
{
	Serial__println_invocations_o4++;
	Serial__println_param_a_o4 = (int)a;
	Serial__println_param_b_o4 = (int)b;

	return Serial__println_return_o4;
}

size_t Serial__println_return_o5;
unsigned int Serial__println_invocations_o5 = 0;
unsigned int Serial__println_param_a_o5;
int Serial__println_param_b_o5;
size_t Serial_::println(unsigned int a, int b)
{
	Serial__println_invocations_o5++;
	Serial__println_param_a_o5 = (unsigned int)a;
	Serial__println_param_b_o5 = (int)b;

	return Serial__println_return_o5;
}

size_t Serial__println_return_o6;
unsigned int Serial__println_invocations_o6 = 0;
long Serial__println_param_a_o6;
int Serial__println_param_b_o6;
size_t Serial_::println(long a, int b)
{
	Serial__println_invocations_o6++;
	Serial__println_param_a_o6 = (long)a;
	Serial__println_param_b_o6 = (int)b;

	return Serial__println_return_o6;
}

size_t Serial__println_return_o7;
unsigned int Serial__println_invocations_o7 = 0;
unsigned long Serial__println_param_a_o7;
int Serial__println_param_b_o7;
size_t Serial_::println(unsigned long a, int b)
{
	Serial__println_invocations_o7++;
	Serial__println_param_a_o7 = (unsigned long)a;
	Serial__println_param_b_o7 = (int)b;

	return Serial__println_return_o7;
}

size_t Serial__println_return_o8;
unsigned int Serial__println_invocations_o8 = 0;
double Serial__println_param_a_o8;
int Serial__println_param_b_o8;
size_t Serial_::println(double a, int b)
{
	Serial__println_invocations_o8++;
	Serial__println_param_a_o8 = (double)a;
	Serial__println_param_b_o8 = (int)b;

	return Serial__println_return_o8;
}

size_t Serial__println_return_o9;
unsigned int Serial__println_invocations_o9 = 0;
size_t Serial_::println()
{
	Serial__println_invocations_o9++;

	return Serial__println_return_o9;
}

size_t Serial__write_return;
unsigned int Serial__write_invocations = 0;
uint8_t * Serial__write_param_buffer;
size_t Serial__write_param_size;
size_t Serial_::write(const uint8_t * buffer, size_t size)
{
	Serial__write_invocations++;
	Serial__write_param_buffer = (uint8_t *)buffer;
	Serial__write_param_size = (size_t)size;

	return Serial__write_return;
}

uint8_t EEPROMClass_read_return;
std::vector<uint8_t> EEPROMClass_read_return_v;
unsigned int EEPROMClass_read_invocations = 0;
int EEPROMClass_read_param_idx;
std::vector<int> EEPROMClass_read_param_idx_v;
uint8_t EEPROMClass::read(int idx)
{
	EEPROMClass_read_invocations++;
	EEPROMClass_read_param_idx = (int)idx;
	EEPROMClass_read_param_idx_v.push_back((int)idx);

	if(EEPROMClass_read_return_v.size() < EEPROMClass_read_invocations)
	{
		return EEPROMClass_read_return;
	}
	else
	{
		return EEPROMClass_read_return_v.at(EEPROMClass_read_invocations-1);
	}
}

unsigned int EEPROMClass_write_invocations = 0;
int EEPROMClass_write_param_idx;
uint8_t EEPROMClass_write_param_val;
void EEPROMClass::write(int idx, uint8_t val)
{
	EEPROMClass_write_invocations++;
	EEPROMClass_write_param_idx = (int)idx;
	EEPROMClass_write_param_val = (uint8_t)val;

}

unsigned int EEPROMClass_update_invocations = 0;
int EEPROMClass_update_param_idx;
std::vector<int> EEPROMClass_update_param_idx_v;
uint8_t EEPROMClass_update_param_val;
std::vector<uint8_t> EEPROMClass_update_param_val_v;
void EEPROMClass::update(int idx, uint8_t val)
{
	EEPROMClass_update_invocations++;
	EEPROMClass_update_param_idx = (int)idx;
	EEPROMClass_update_param_idx_v.push_back((int)idx);
	EEPROMClass_update_param_val = (uint8_t)val;
	EEPROMClass_update_param_val_v.push_back((uint8_t)val);

}

uint16_t EEPROMClass_length_return;
std::vector<uint16_t> EEPROMClass_length_return_v;
unsigned int EEPROMClass_length_invocations = 0;
uint16_t EEPROMClass::length()
{
	EEPROMClass_length_invocations++;

	if(EEPROMClass_length_return_v.size() < EEPROMClass_length_invocations)
	{
		return EEPROMClass_length_return;
	}
	else
	{
		return EEPROMClass_length_return_v.at(EEPROMClass_length_invocations-1);
	}
}

uint16_t  EEPROMClass_get_return_o1;
std::vector<uint16_t > EEPROMClass_get_return_o1_v;
unsigned int EEPROMClass_get_invocations_o1 = 0;
int EEPROMClass_get_param_idx_o1;
std::vector<int> EEPROMClass_get_param_idx_o1_v;
uint16_t  EEPROMClass_get_param_t_o1;
std::vector<uint16_t > EEPROMClass_get_param_t_o1_v;
uint16_t  EEPROMClass_get_param_t_o1_r;
std::vector<uint16_t > EEPROMClass_get_param_t_o1_vr;
uint16_t & EEPROMClass::get(int idx, uint16_t & t)
{
	EEPROMClass_get_invocations_o1++;
	EEPROMClass_get_param_idx_o1 = (int)idx;
	EEPROMClass_get_param_idx_o1_v.push_back((int)idx);
	EEPROMClass_get_param_t_o1 = (uint16_t &)t;
	EEPROMClass_get_param_t_o1_v.push_back((uint16_t &)t);

	if(EEPROMClass_get_param_t_o1_vr.size() < EEPROMClass_get_invocations_o1) t = (uint16_t &)EEPROMClass_get_param_t_o1_r;
	else t = (uint16_t &)EEPROMClass_get_param_t_o1_vr.at(EEPROMClass_get_invocations_o1-1);

	if(EEPROMClass_get_return_o1_v.size() < EEPROMClass_get_invocations_o1)
	{
		return EEPROMClass_get_return_o1;
	}
	else
	{
		return EEPROMClass_get_return_o1_v.at(EEPROMClass_get_invocations_o1-1);
	}
}

uint32_t  EEPROMClass_get_return_o2;
std::vector<uint32_t > EEPROMClass_get_return_o2_v;
unsigned int EEPROMClass_get_invocations_o2 = 0;
int EEPROMClass_get_param_idx_o2;
std::vector<int> EEPROMClass_get_param_idx_o2_v;
uint32_t  EEPROMClass_get_param_t_o2;
std::vector<uint32_t > EEPROMClass_get_param_t_o2_v;
uint32_t  EEPROMClass_get_param_t_o2_r;
std::vector<uint32_t > EEPROMClass_get_param_t_o2_vr;
uint32_t & EEPROMClass::get(int idx, uint32_t & t)
{
	EEPROMClass_get_invocations_o2++;
	EEPROMClass_get_param_idx_o2 = (int)idx;
	EEPROMClass_get_param_idx_o2_v.push_back((int)idx);
	EEPROMClass_get_param_t_o2 = (uint32_t &)t;
	EEPROMClass_get_param_t_o2_v.push_back((uint32_t &)t);

	if(EEPROMClass_get_param_t_o2_vr.size() < EEPROMClass_get_invocations_o2) t = (uint32_t &)EEPROMClass_get_param_t_o2_r;
	else t = (uint32_t &)EEPROMClass_get_param_t_o2_vr.at(EEPROMClass_get_invocations_o2-1);

	if(EEPROMClass_get_return_o2_v.size() < EEPROMClass_get_invocations_o2)
	{
		return EEPROMClass_get_return_o2;
	}
	else
	{
		return EEPROMClass_get_return_o2_v.at(EEPROMClass_get_invocations_o2-1);
	}
}

uint8_t  EEPROMClass_get_return_o3;
std::vector<uint8_t > EEPROMClass_get_return_o3_v;
unsigned int EEPROMClass_get_invocations_o3 = 0;
int EEPROMClass_get_param_idx_o3;
std::vector<int> EEPROMClass_get_param_idx_o3_v;
uint8_t  EEPROMClass_get_param_t_o3;
std::vector<uint8_t > EEPROMClass_get_param_t_o3_v;
uint8_t  EEPROMClass_get_param_t_o3_r;
std::vector<uint8_t > EEPROMClass_get_param_t_o3_vr;
uint8_t & EEPROMClass::get(int idx, uint8_t & t)
{
	EEPROMClass_get_invocations_o3++;
	EEPROMClass_get_param_idx_o3 = (int)idx;
	EEPROMClass_get_param_idx_o3_v.push_back((int)idx);
	EEPROMClass_get_param_t_o3 = (uint8_t &)t;
	EEPROMClass_get_param_t_o3_v.push_back((uint8_t &)t);

	if(EEPROMClass_get_param_t_o3_vr.size() < EEPROMClass_get_invocations_o3) t = (uint8_t &)EEPROMClass_get_param_t_o3_r;
	else t = (uint8_t &)EEPROMClass_get_param_t_o3_vr.at(EEPROMClass_get_invocations_o3-1);

	if(EEPROMClass_get_return_o3_v.size() < EEPROMClass_get_invocations_o3)
	{
		return EEPROMClass_get_return_o3;
	}
	else
	{
		return EEPROMClass_get_return_o3_v.at(EEPROMClass_get_invocations_o3-1);
	}
}

uint8_t EEPROMClass_put_return_o1;
std::vector<uint8_t> EEPROMClass_put_return_o1_v;
unsigned int EEPROMClass_put_invocations_o1 = 0;
int EEPROMClass_put_param_idx_o1;
std::vector<int> EEPROMClass_put_param_idx_o1_v;
uint8_t EEPROMClass_put_param_t_o1;
std::vector<uint8_t> EEPROMClass_put_param_t_o1_v;
const uint8_t & EEPROMClass::put(int idx, const uint8_t & t)
{
	EEPROMClass_put_invocations_o1++;
	EEPROMClass_put_param_idx_o1 = (int)idx;
	EEPROMClass_put_param_idx_o1_v.push_back((int)idx);
	EEPROMClass_put_param_t_o1 = (uint8_t &)t;
	EEPROMClass_put_param_t_o1_v.push_back((uint8_t &)t);

	if(EEPROMClass_put_return_o1_v.size() < EEPROMClass_put_invocations_o1)
	{
		return EEPROMClass_put_return_o1;
	}
	else
	{
		return EEPROMClass_put_return_o1_v.at(EEPROMClass_put_invocations_o1-1);
	}
}

uint16_t EEPROMClass_put_return_o2;
std::vector<uint16_t> EEPROMClass_put_return_o2_v;
unsigned int EEPROMClass_put_invocations_o2 = 0;
int EEPROMClass_put_param_idx_o2;
std::vector<int> EEPROMClass_put_param_idx_o2_v;
uint16_t EEPROMClass_put_param_t_o2;
std::vector<uint16_t> EEPROMClass_put_param_t_o2_v;
const uint16_t & EEPROMClass::put(int idx, const uint16_t & t)
{
	EEPROMClass_put_invocations_o2++;
	EEPROMClass_put_param_idx_o2 = (int)idx;
	EEPROMClass_put_param_idx_o2_v.push_back((int)idx);
	EEPROMClass_put_param_t_o2 = (uint16_t &)t;
	EEPROMClass_put_param_t_o2_v.push_back((uint16_t &)t);

	if(EEPROMClass_put_return_o2_v.size() < EEPROMClass_put_invocations_o2)
	{
		return EEPROMClass_put_return_o2;
	}
	else
	{
		return EEPROMClass_put_return_o2_v.at(EEPROMClass_put_invocations_o2-1);
	}
}

uint32_t EEPROMClass_put_return_o3;
std::vector<uint32_t> EEPROMClass_put_return_o3_v;
unsigned int EEPROMClass_put_invocations_o3 = 0;
int EEPROMClass_put_param_idx_o3;
std::vector<int> EEPROMClass_put_param_idx_o3_v;
uint32_t EEPROMClass_put_param_t_o3;
std::vector<uint32_t> EEPROMClass_put_param_t_o3_v;
const uint32_t & EEPROMClass::put(int idx, const uint32_t & t)
{
	EEPROMClass_put_invocations_o3++;
	EEPROMClass_put_param_idx_o3 = (int)idx;
	EEPROMClass_put_param_idx_o3_v.push_back((int)idx);
	EEPROMClass_put_param_t_o3 = (uint32_t &)t;
	EEPROMClass_put_param_t_o3_v.push_back((uint32_t &)t);

	if(EEPROMClass_put_return_o3_v.size() < EEPROMClass_put_invocations_o3)
	{
		return EEPROMClass_put_return_o3;
	}
	else
	{
		return EEPROMClass_put_return_o3_v.at(EEPROMClass_put_invocations_o3-1);
	}
}


void ResetMocks() 
{
	digitalRead_param_pin = uint8_t();
	digitalRead_invocations = 0;
	digitalRead_return = int();
	pinMode_param_pin = uint8_t();
	pinMode_param_pin_v.clear();
	pinMode_param_mode = uint8_t();
	pinMode_param_mode_v.clear();
	pinMode_invocations = 0;
	millis_invocations = 0;
	millis_return = long();
	digitalWrite_param_pin = uint8_t();
	digitalWrite_param_val = uint8_t();
	digitalWrite_invocations = 0;
	delay_param_ms = long();
	delay_invocations = 0;
	pow_param_base = double();
	pow_param_exponent = double();
	pow_invocations = 0;
	pow_return = double();
	Serial__print_param_a_o1 = nullptr;
	Serial__print_invocations_o1 = 0;
	Serial__print_return_o1 = size_t();
	Serial__print_param_a_o2 = char();
	Serial__print_invocations_o2 = 0;
	Serial__print_return_o2 = size_t();
	Serial__print_param_a_o3 = char();
	Serial__print_param_b_o3 = int();
	Serial__print_invocations_o3 = 0;
	Serial__print_return_o3 = size_t();
	Serial__print_param_a_o4 = int();
	Serial__print_param_b_o4 = int();
	Serial__print_invocations_o4 = 0;
	Serial__print_return_o4 = size_t();
	Serial__print_param_a_o5 = int();
	Serial__print_param_b_o5 = int();
	Serial__print_invocations_o5 = 0;
	Serial__print_return_o5 = size_t();
	Serial__print_param_a_o6 = long();
	Serial__print_param_b_o6 = int();
	Serial__print_invocations_o6 = 0;
	Serial__print_return_o6 = size_t();
	Serial__print_param_a_o7 = long();
	Serial__print_param_b_o7 = int();
	Serial__print_invocations_o7 = 0;
	Serial__print_return_o7 = size_t();
	Serial__print_param_a_o8 = double();
	Serial__print_param_b_o8 = int();
	Serial__print_invocations_o8 = 0;
	Serial__print_return_o8 = size_t();
	Serial__println_param_a_o1 = nullptr;
	Serial__println_invocations_o1 = 0;
	Serial__println_return_o1 = size_t();
	Serial__println_param_b_o2 = char();
	Serial__println_invocations_o2 = 0;
	Serial__println_return_o2 = size_t();
	Serial__println_param_a_o3 = char();
	Serial__println_param_b_o3 = int();
	Serial__println_invocations_o3 = 0;
	Serial__println_return_o3 = size_t();
	Serial__println_param_a_o4 = int();
	Serial__println_param_b_o4 = int();
	Serial__println_invocations_o4 = 0;
	Serial__println_return_o4 = size_t();
	Serial__println_param_a_o5 = int();
	Serial__println_param_b_o5 = int();
	Serial__println_invocations_o5 = 0;
	Serial__println_return_o5 = size_t();
	Serial__println_param_a_o6 = long();
	Serial__println_param_b_o6 = int();
	Serial__println_invocations_o6 = 0;
	Serial__println_return_o6 = size_t();
	Serial__println_param_a_o7 = long();
	Serial__println_param_b_o7 = int();
	Serial__println_invocations_o7 = 0;
	Serial__println_return_o7 = size_t();
	Serial__println_param_a_o8 = double();
	Serial__println_param_b_o8 = int();
	Serial__println_invocations_o8 = 0;
	Serial__println_return_o8 = size_t();
	Serial__println_invocations_o9 = 0;
	Serial__println_return_o9 = size_t();
	Serial__write_param_buffer = nullptr;
	Serial__write_param_size = size_t();
	Serial__write_invocations = 0;
	Serial__write_return = size_t();
	EEPROMClass_read_param_idx = int();
	EEPROMClass_read_param_idx_v.clear();
	EEPROMClass_read_invocations = 0;
	EEPROMClass_read_return = uint8_t();
	EEPROMClass_read_return_v.clear();
	EEPROMClass_write_param_idx = int();
	EEPROMClass_write_param_val = uint8_t();
	EEPROMClass_write_invocations = 0;
	EEPROMClass_update_param_idx = int();
	EEPROMClass_update_param_idx_v.clear();
	EEPROMClass_update_param_val = uint8_t();
	EEPROMClass_update_param_val_v.clear();
	EEPROMClass_update_invocations = 0;
	EEPROMClass_length_invocations = 0;
	EEPROMClass_length_return = uint16_t();
	EEPROMClass_length_return_v.clear();
	EEPROMClass_get_param_idx_o1 = int();
	EEPROMClass_get_param_idx_o1_v.clear();
	EEPROMClass_get_param_t_o1 = uint16_t();
	EEPROMClass_get_param_t_o1_v.clear();
	EEPROMClass_get_param_t_o1_r = uint16_t();
	EEPROMClass_get_param_t_o1_vr.clear();
	EEPROMClass_get_invocations_o1 = 0;
	EEPROMClass_get_return_o1 = uint16_t();
	EEPROMClass_get_return_o1_v.clear();
	EEPROMClass_get_param_idx_o2 = int();
	EEPROMClass_get_param_idx_o2_v.clear();
	EEPROMClass_get_param_t_o2 = uint32_t();
	EEPROMClass_get_param_t_o2_v.clear();
	EEPROMClass_get_param_t_o2_r = uint32_t();
	EEPROMClass_get_param_t_o2_vr.clear();
	EEPROMClass_get_invocations_o2 = 0;
	EEPROMClass_get_return_o2 = uint32_t();
	EEPROMClass_get_return_o2_v.clear();
	EEPROMClass_get_param_idx_o3 = int();
	EEPROMClass_get_param_idx_o3_v.clear();
	EEPROMClass_get_param_t_o3 = uint8_t();
	EEPROMClass_get_param_t_o3_v.clear();
	EEPROMClass_get_param_t_o3_r = uint8_t();
	EEPROMClass_get_param_t_o3_vr.clear();
	EEPROMClass_get_invocations_o3 = 0;
	EEPROMClass_get_return_o3 = uint8_t();
	EEPROMClass_get_return_o3_v.clear();
	EEPROMClass_put_param_idx_o1 = int();
	EEPROMClass_put_param_idx_o1_v.clear();
	EEPROMClass_put_param_t_o1 = uint8_t();
	EEPROMClass_put_param_t_o1_v.clear();
	EEPROMClass_put_invocations_o1 = 0;
	EEPROMClass_put_return_o1 = uint8_t();
	EEPROMClass_put_return_o1_v.clear();
	EEPROMClass_put_param_idx_o2 = int();
	EEPROMClass_put_param_idx_o2_v.clear();
	EEPROMClass_put_param_t_o2 = uint16_t();
	EEPROMClass_put_param_t_o2_v.clear();
	EEPROMClass_put_invocations_o2 = 0;
	EEPROMClass_put_return_o2 = uint16_t();
	EEPROMClass_put_return_o2_v.clear();
	EEPROMClass_put_param_idx_o3 = int();
	EEPROMClass_put_param_idx_o3_v.clear();
	EEPROMClass_put_param_t_o3 = uint32_t();
	EEPROMClass_put_param_t_o3_v.clear();
	EEPROMClass_put_invocations_o3 = 0;
	EEPROMClass_put_return_o3 = uint32_t();
	EEPROMClass_put_return_o3_v.clear();
}

#pragma GCC diagnostic pop

void Controller_Constructor_ReadsSizeOfEEPROMAndSavesItToStorageSizeVariable();
void Controller_Constructor_CopiesProvidedKeymapsIntoClass();
void Controller_Constructor_AllocatesEnoughSpaceForPointers();
void Controller_Constructor_AmountOfFreeStorageIsEqualToTheStorageSize();
void CyclicEepromAdress_TakesInAnAdressThatExceedsTheEepromsSize_WrapsBackToTheBeginningOfTheEeprom();
void CyclicEepromAdress_AdressOvershootsEepromSizeWithOneStep_ReturnsTheFirstAdressOftheEeprom();
void CyclicEepromAdress_TakesInAnAdressThatExceedsTheEepromsSize_CalculatesTheNewAdressCorrectly();
void CyclicEepromAdress_AdressIsWithinEepromsSize_AdressIsUnchanged();
void RetrieveBareKeyboardKeysFromMemory_RetrievesFaultyData_DoesNotCrashAndReturnsFalse();
void RetrieveBareKeyboardKeysFromMemory_FindsPacketAndReturnsTheBareKeyboardKeysInside();
void RetrieveBareKeyboardKeysFromMemory_FindsDefectPacket_ReturnsFalse();
void RetrieveBareKeyboardKeysFromMemory_EepromHasDefectPacketFollowedByValidPacket_ReturnsKeysFromValidPacket();
void ConvertDataPacketToBareKeyboardKeys_RetrievesCorrectPacketWithFaultyPayload_DoesNotCrash();
void ConvertDataPacketToBareKeyboardKeys_SuccessfullyConvertsPacketIntoListOfBareKeyboardKeys();
void ParseBareKeyboardKeyArrayIntoKeymapList_PopulatesTheListWithTheGivenKeys();
void IsKeyValid_ThePinOfTheKeyIsPresentInTheDefaultKeymap_ReturnsTrue();
void IsKeyValid_ThePinOfTheKeyIsNotPresentInTheDefaultKeymap_ReturnsFalse();
void LoadKeymapsFromMemoryIntoList_CorrectlyLoadsKeymapIntoList();
void LoadKeymapsFromMemoryIntoList_LoadsKeymap_SetsEepromAdressToTheLoadedPacketsAdress();
void LoadKeymapsFromMemoryIntoList_LoadsKeymap_SetsNextFreeEepromAdressToAFreeAdressAfterTheEndOfTheLoadedPacket();
void LoadKeymapsFromMemoryIntoList_LoadsKeymap_SetsTheAmountOfFreeStorageToBeEqualToTheStorageSizeMinusTheSizeOfTheLoadedPacket();
void LoadKeymapsFromMemoryIntoList_FailsToLoadKeymap_DoesNotChangeAmountOfFreeStorage();
void LoadKeymapsFromMemoryIntoList_LoadsKeymapThatExceedsTheEepromsLastAdress_DoesNotUpdateNextPacketAdressWithAnAdressOutsideTheEeprom();
void LoadKeymapsFromMemoryIntoList_EepromHasDefectKeymaps_DoesNotLoadKeymaps();
void LoadKeymapsFromMemoryIntoList_EepromHasDefectKeymapsFollowedByValidKeymaps_LoadsTheValidKeymaps();
void WipeKeyboardEventBuffer_BufferOnlyContainsZeroes();
void SendKeyboardEvent_CallsSerialWriteWithTheCorrectBufferSize();
void SendKeyboardEvent_CallsSerialWriteWithTheCorrectBuffer();
void ChangeKeyMap_TheDefaultKeymapIsEquipped_isUsingDefaultKeymapIsAssignedToTrue();
void ChangeKeyMap_ACustomKeymapIsEquipped_isUsingDefaultKeymapIsAssignedFalse();
void ChangeKeyMap_ACustomKeymapWithSimilarButNotTheSameSettingsAsDefaultKeymapIsEquipped_isUsingDefaultKeymapIsAssignedFalse();
void ChangeKeyMap_DefaultKeymapIsSelectedAndWeAreEquippingACustomKeymap_CurrentKeymapNowContainsKeysOfCustomKeymap();
void ChangeKeyMap_EmptiesBufferAndSendsItAsAKeyReleaseEventForAllKeys();
void ChangeKeyMap_ConfiguresThePinsOfTheProvidedKeymap();
void CycleKeyMap_TheDefaultKeymapIsCurrentlyEquipped_EquipsTheFirstKeymapInTheList();
void CycleKeyMap_TheDefaultKeymapIsCurrentlyEquippedAndWeCycleTwice_EquipsTheSecondKeymapInTheList();
void CycleKeyMap_TheDefaultKeymapIsCurrentlyEquippedAndWeOnlyhaveTwoCustomKeymapsAndWeCycleThreeTimes_WhenWeCycleOffTheLastCustomKeymapItLoopsBackToTheFirstKeymapInTheList();
void SaveKeyMapsToMemory_PutsDownKeysAsBareKeyboardKeyArrayIntoEEPROM();
void SaveKeyMapsToMemory_Succeeds_ReturnsTrue();
void SaveKeyMapsToMemory_UpdatesCurrentPacketAdressWithTheAdressOfTheSavedPacket();
void SaveKeyMapsToMemory_UpdatesNextPacketAdressWithAFreeAdress();
void SaveKeyMapsToMemory_SavesKeymaps_SetsTheAmountOfFreeStorageToBeEqualToTheStorageSizeMinusTheSizeOfTheSavedPacket();
void SaveKeyMapsToMemory_FailsToSavePacket_DoesNotChangeAmountOfFreeStorage();
void SaveKeyMapsToMemory_SavedPacketExceedsTheLastAdressOfTheEeprom_DoesNotSetNextPacketAdressToAnAdressOutsideTheEeprom();
void SaveKeyMapsToMemory_PacketIsSavedAtTheNextPacketAdress();
void SaveKeyMapsToMemory_PacketIsSavedSuccessfully_DeactivatesOldPacket();
void SaveKeyMapsToMemory_CurrentPacketAdressAndNextPacketAdressAreTheSame_SuccessfullySavesPacket_DoesNotDeactivateTheSavedPacket();
void SaveKeyMapsToMemory_FailedToSavePacket_DoesNotDeactivateOldPacket();
void SaveKeyMapsToMemory_TheFunctionFailsBecauseTheSavedPacketCanNotBeRead_ReturnsFalse();
void ToggleEditMode_CurrentKeymapHasBeenEdited_UpdatesTheEquippedCustomKeymapWithTheValuesPresentInCurrentKeymap();
void SaveControllerSettings_CurrentKeymapHasBeenEdited_UpdatesTheEquippedCustomKeymapWithTheValuesPresentInCurrentKeymap();
void UpdateCurrentCustomKeymap_CurrentKeymapHasBeenEdited_UpdatesTheEquippedCustomKeymapWithTheValuesPresentInCurrentKeymap();
void UpdateCurrentCustomKeymap_CurrentKeymapHasBeenEditedAndTheSecondCustomKeymapIsSelected_UpdatesTheSelectedCustomKeymap();
void UpdateCurrentCustomKeymap_CurrentKeymapHasBeenEditedAndTheSecondCustomKeymapIsSelected_DoesNotChangeTheOtherKeymaps();
void CreateNewKeymap_SuccessfullyCreatesAKeymapInCustomKeymaps();
void CreateNewKeymap_SuccessfullyCreatesAKeymap_ReturnsTrue();
void CreateNewKeymap_SuccessfullyCreatesAKeymap_KeymapIsAddedToTheEndOfTheCustomKeymapList();
void CreateNewKeymap_SuccessfullyCreatesAKeymap_NewKeymapInheritsPinsFromDefaultKeymap();
void CreateNewKeymap_SuccessfullyCreatesAKeymap_KeycodesOnNewKeymapsDefaultTo4();
void CreateNewKeymap_SuccessfullyCreatesAKeymap_EquipsTheNewKeymap();
void CreateNewKeymap_WeHaveEnoughFreeMemory_CreatesKeymapAndReturnsTrue();
void CreateNewKeymap_DoesNotHaveEnoughMemoryLeft_DoesNotCreateAKeymapAndReturnsFalse();
void Helper_ReadDataPacketOnEEPROM_PrepareToReturnPacket_ParsePacketFromEepromSuccessfullyReturnsCorrectPacket();
void Helper_ReadDataPacketOnEEPROM_PrepareToReturnPacket_SetEepromSizeByHandToFitThePacket_ParsePacketFromEepromSuccessfullyReturnsCorrectPacket();
void Helper_ReadDataPacketOnEEPROM_PrepareToReturnPacket_UsingHighAdress_EepromLengthIsSetToFitPacket();
void Helper_ReadDataPacketOnEEPROM_PrepareToReturnPacket_SetEepromSizeByHandToNotFitThePacket_ReadDataPacketOnEEPROMFails();
void Helper_ReadDataPacketOnEEPROM_PrepareToReturnPacket_ParsePacketFromEepromRecievesInactiveFlag();
void Helper_SaveDataPacketToEEPROM_PreparesEepromSizeAndPrepareToReturnPacket_SaveDataPacketToEEPROMReturnsTrueAndReturnsCorrectPacketSize();
void Helper_SaveDataPacketToEEPROM_PreparesEepromSizeAndPrepareToReturnPacket_SetEepromSizeByHandToNotFitPacket_ReturnsFalse();
void Helper_SaveDataPacketToEEPROM_PreparesEepromSizeAndPrepareToReturnPacket_SetEepromSizeByHandToFitPacket_ReturnsTrue();
void Helper_SaveDataPacketToEEPROM_PreparesEepromSizeAndPrepareToReturnPacket_WeProvideNoEepromSize_SetsEepromSizeAutomaticallyToFitOurPacket();
void Helper_SaveDataPacketToEEPROM_PreparesEepromSizeAndPrepareToReturnPacket_UsingHighAdress_EepromLengthIsSetToFitPacket();
void Helper_CalculateSizeOfPacketOnEEPROM_ReturnsCorrectSizeOfPacket();
void DataPacket_Constructor_NoArguments_AllocatesSpaceForPayload();
void DataPacket_Constructor_WithArguments_CopiesDataIntoPayload();
void DataPacket_Constructor_WithArguments_SetsUpPacketCorrectly();
void DataPacket_CopyConstructor_CopiesValuesAndPayload();
void DataPacket_CopyConstructor_PayloadIsCopiedAndIndependent();
void DataToPacket_TakesInDataOfTypeT_ConvertsItCorrectlyIntoADataPacket();
void DataToPacket_TakesInDataOfTypeBool_CanHandleDifferentTypes();
void DataPacket_ByDefault_StxIsTwo();
void DataPacket_ByDefault_EtxIsThree();
void DataPacket_ByDefault_ActiveIsTrue();
void CalculateCRC_UsesAlgorithCRC32();
void CyclicAdress_TakesInAnAdressThatExceedsTheBufferSize_WrapsBackToTheBeginningOfTheBuffer();
void CyclicAdress_AdressOvershootsLastBufferAdressWithOneStep_ReturnsTheFirstAdressOftheBuffer();
void CyclicAdress_TakesInAnAdressThatExceedsTheLastAdressOfTheBuffer_CalculatesTheNewAdressCorrectly();
void CyclicAdress_OvershootsWholeBufferMultipleTimes_ReturnsAdressWithinBuffersSize();
void CyclicAdress_CalculatesNewAdressDependingOnBufferSize_ReturnsCorrectAdress();
void CyclicAdress_ProvidedAdressIsWithinBuffersSize_AdressIsUnchanged();
void CyclicAdress_BufferSizeIsZero_ReturnsZero();
void SizeOfSerializedDataPacket_ReturnsTheAmountOfBytesTheDataPacketWillOccupyOnMemory();
void SizeOfSerializedDataPacket_CalculatesSizeDependingOnTheSizeOfThePayload();
void SizeOfSerializedDataPacket_MustReturnTheSameSizeAsSaveDataPacketPacketToEEPROM();
void SaveDataPacketToEEPROM_SavesStxToFirstGivenAdress();
void SaveDataPacketToEEPROM_EtxIsPutDownAtTheEndOfThePacket();
void SaveDataPacketToEEPROM_PacketIsCorrectlyPutDown();
void SaveDataPacketToEEPROM_PacketWillExceedEndOfEEPROM_ReturnsCorrectPacketSize();
void SaveDataPacketToEEPROM_PacketWillExceedEndOfEEPROM_SplitsPacketBetweenEndAndStartOfEEPROM();
void SaveDataPacketToEEPROM_SplitsPacketOnPayload_PutsDownPayloadOnCorrectAdresses();
void SaveDataPacketToEEPROM_PacketIsSavedButEepromFailsToReadTheData_ReturnsFalse();
void SaveDataPacketToEEPROM_AdaptsSizeOfPacketToFitData();
void SaveDataPacketToEEPROM_AdressIsOutsideOfEEPROMsRange_ReturnsFalse();
void SaveDataPacketToEEPROM_AdressIsOutsideOfEEPROMsRange_DoesNotWriteAnythingToEEPROM();
void SaveDataPacketToEEPROM_PacketIsTooBigForEEPROM_DoesNotWriteToMemoryAndReturnsFalse();
void SaveDataPacketToEEPROM_PacketFitsOnEEPROM_ReturnsTrue();
void ReadDataPacketOnEEPROM_DataPacketDoesNotNeedToBeManuallyAllocatedBeforePassedToFunciton_DoesNotCrash();
void ReadDataPacketOnEEPROM_ReturnsCorrectPacket();
void ReadDataPacketOnEEPROM_PacketIsSplitBetweenEndAndStartOfEEPROM_ReturnsCorrectPacketSize();
void ReadDataPacketOnEEPROM_PacketIsSplitBetweenEndAndStartOfEEPROM_SuccessfullyReadsPacket();
void ReadDataPacketOnEEPROM_PacketsPayloadIsSplitBetweenEndAndStartOfEEPROM_SuccessfullyReadsPayload();
void ReadDataPacketOnEEPROM_ReturnsFalseWhenAValidPacketIsNotActive();
void ReadDataPacketOnEEPROM_ReturnsTrueWhenAValidPacketIsActive();
void ReadDataPacketOnEEPROM_EepromReturnsFaultyData_ReturnsFalse();
void ReadDataPacketOnEEPROM_AdressIsOutOfEEPROMsRange_ReturnsFalse();
void IsPacketActive_PacketsActiveFlagIsOne_ReturnsTrue();
void IsPacketActive_PacketsActiveFlagIsZero_ReturnsFalse();
void IsPacketActive_PacketsActiveFlagIsNotOne_ReturnsFalse();
void DeactivatePacket_OverritesCorrectByteWithADeactivatedFlag();
void DeactivatePacket_ReadsStxPayloadLengthAndEtxFromTheRightPlaces();
void DeactivatePacket_DeactivatesPacketSuccessfully_ReturnsTrue();
void DeactivatePacket_StxIsAtTheLastAdressAndActiveFlagIsOnTheFirstAdressOfEeprom_DeactivatesTheCorrectAdress();
void DeactivatePacket_AdressDoesNotPointToStx_ReturnsFalse();
void DeactivatePacket_AdressDoesNotPointToStx_DoesNotWriteToEEPROM();
void DeactivatePacket_AdressIsOutOfRangeOfEeprom_ReturnsFalseAndDoesNotWriteToEeprom();
void DeactivatePacket_AdressPointsToStxButCantFindEtxOfPacket_ReturnsFalse();
void DeactivatePacket_AdressPointsToStxButCantFindEtxOfPacket_DoesNotWriteToEEPROM();
void FindFirstDataPacketOnEEPROM_TakesInAStartAdress_BeginsLookingAtTheGivenAdress();
void FindFirstDataPacketOnEEPROM_FindsPacket_ReturnsTrue();
void FindFirstDataPacketOnEEPROM_PacketIsPresentAfterGarbageData_FindsPacket();
void FindFirstDataPacketOnEEPROM_PacketIsPresentAfterGarbageData_FindsPacketOnCorrectAdress();
void FindFirstDataPacketOnEEPROM_FindsPacket_ReturnsCorrectPacketSize();
void FindFirstDataPacketOnEEPROM_NoPacketIsPresent_LooksAtEveryPositionOfTheEeprom();
void FindFirstDataPacketOnEEPROM_NoPacketIsPresent_ReturnsFalse();
void FindFirstDataPacketOnEEPROM_PacketIsPresentOnEEPROMButStartAdressIsOutOfRange_ReturnsFalse();
void DeactivateAllPacketsOnEEPROM_OnePacketIsPresent_OverwritesPacketWithADeactivatedFlag();
void DeactivateAllPacketsOnEEPROM_OverwritesPacketWithADeactivatedFlag_ReturnsTrue();
void DeactivateAllPacketsOnEEPROM_ADeactivatedPacketIsPresent_DoesNotOverwritePacket();
void DeactivateAllPacketsOnEEPROM_OnePacketIsPresentAfterGarbageData_OverwritesCorrectPositionWithADeactivatedFlag();
void DeactivateAllPacketsOnEEPROM_MultiplePacketsArePresent_OverwritesAllPacketsWithADeactivatedFlag();
void DeactivateAllPacketsOnEEPROM_NoPacketIsPresent_DoesNotWriteToEEPROM();
void DeactivateAllPacketsOnEEPROM_NoPacketIsPresent_ReturnsFalse();
void EditMode_Constructor_SetsCorrectValues();
void EditMode_Initialized_NotEnabledByDefault();
void Toggle_WhenDisabled_BecomesEnabled();
void Toggle_WhenEnabled_BecomesDisabled();
void Reset_SelectedKeyNotReset_BecomesNullptr();
void Reset_KeysPressedNotReset_BecomesZero();
void Reset_InputKeyCodeNotReset_BecomesZero();
void Reset_ShouldAddValueNotReset_BecomesFalse();
void Reset_BlinkValuesNotReset_BecomesResetToInitialValues();
void Reset_BuiltinLedIsOn_IsTurnedOff();
void CopyKeyMapToTemporary_TempCopyIsOverwrittenWithTheValuesOfTheProvidedKeyMap();
void RestoreKeyMapFromTemporaryCopy_ProvidedKeyMapIsRestoredToStateWhenCopyKeyMapToTemporaryWasCalled();
void RestoreKeyMapFromTemporaryCopy_ResetEditMode();
void RegisterKeyPress_AddsOneToKeysPressed();
void RegisterKeyPress_IfNoKeyIsSelected_SelectProvidedKey();
void RegisterKeyPress_IfKeyHasAlreadyBeenSelected_DoNotUpdateSelectedKey();
void RegisterKeyPress_TheFirstKeyIsBeingPressed_ShouldNotPrepareToAddValueToKey();
void RegisterKeyPress_FirstKeyHasAlreadyBeenRegistered_PrepareToAddValueToTheKey();
void RegisterKeyRelease_KeysPressedIsDecreasedByOne();
void RegisterKeyRelease_SelectedKeyIsNullptrAndOneKeyIsPressed_PreventsAccessingSelectedKeyWhenNullptr();
void RegisterKeyRelease_ShouldAddValueIsTrue_InputKeyCodeIsChanged();
void RegisterKeyRelease_ShouldAddValueIsTrue_CorrectValueIsAddedToInputKeyCode();
void RegisterKeyRelease_TwoKeysWerePressedBeforeReleasing_ProvidesExponentZeroAndBaseTenToPow();
void RegisterKeyRelease_ThreeKeysWerePressedBeforeReleasing_ProvidesExponentOneAndBaseTenToPow();
void RegisterKeyRelease_FourKeysWerePressedBeforeReleasing_ProvidesExponentTwoAndBaseTenToPow();
void RegisterKeyRelease_AfterAddingValue_PreventNextKeyReleaseFromAddingValueToInputKeyCode();
void RegisterKeyRelease_LastKeyIsReleased_AppliesInputKeyCodeToKeyBeingEdited();
void RegisterKeyRelease_LastKeyIsReleased_ResetsUsedVariables();
void RegisterKeyRelease_ShouldNotAddValue_InputKeyCodeRemainsTheSame();
void EditModeLoop_KeyHasNotBeenChanged_DoesNotDoAnything();
void EditModeLoop_KeyBecamePressed_RegistersKeyPress();
void EditModeLoop_TwoKeysBecamePressed_RegistersTwoKeyPresses();
void EditModeLoop_KeyBecameReleased_RegistersKeyRelease();
void EditModeLoop_TwoKeysBecameReleased_RegistersTwoKeyReleases();
void EditModeLoop_WhenIdle_SignalEditMode();
void KeyConstructor_NoArguments_IntializesPinAndKeycodeWithZeroAndIPinStateWithDefaultValues();
void KeyConstructor_WithArguments_IntializesPinAndKeycodeCorrectly();
void SpecialKeyConstructor_NoArguments_IntializesPinAndFunctionCorrectly();
void SpecialKeyConstructor_WithArguments_IntializesPinAndFunctionCorrectly();
void BareKeyboardKeyConstructor_NoArguments_IntializesPinAndKeycodeWithZero();
void BareKeyboardKeyConstructor_WithArguments_IntializesPinAndKeycodeCorrectly();
void SpecialKeyEqualityOperator_PinAndFunctionAreTheSameBetweenObjects_ReturnsTrue();
void SpecialKeyEqualityOperator_PinDifferBetweenObjects_ReturnsFalse();
void SpecialKeyEqualityOperator_FunctionDifferBetweenObjects_ReturnsFalse();
void SpecialKeyEqualityOperator_PinAndFunctionAreTheSameBetweenObjectsButStateIsDifferent_IgnoresStateAndReturnsTrue();
void SpecialKeyNotEqualityOperator_PinAndFunctionDifferBetweenObjects_ReturnsOppositeOfEqualityOperator();
void SpecialKeyNotEqualityOperator_PinAndFunctionAreTheSameBetweenObjects_ReturnsOppositeOfEqualityOperator();
void BareKeyboardKeyEqualityOperator_PinAndKeycodeAreTheSameBetweenObjects_ReturnsTrue();
void BareKeyboardKeyEqualityOperator_PinDifferBetweenObjects_ReturnsFalse();
void BareKeyboardKeyEqualityOperator_KeycodeDifferBetweenObjects_ReturnsFalse();
void BareKeyboardKeyNotEqualityOperator_PinAndKeycodeDifferBetweenObjects_ReturnsOppositeOfEqualityOperator();
void BareKeyboardKeyNotEqualityOperator_PinAndKeycodeAreTheSameBetweenObjects_ReturnsOppositeOfEqualityOperator();
void ConfigurePinForKey_IKeyIsPassedToPinMode();
void ConfigurePinForKeyOfTypeKey_IsCorrectlyParsedToIKey();
void ConfigurePinForKeyOfTypeSpecialKey_IsCorrectlyParsedToIKey();
void ConfigurePinForKey_ConfiguresPinAsInputPullup();
void ConfigurePinForKey_CallsPinModeOnce();
void OnKeyPress_PinStateWentFromInactiveToActive_ReturnsTrue();
void OnKeyPress_PinStateValueDidNotChange_ReturnsFalse();
void OnKeyPress_PinStateIsInactive_ReturnFalse();
void OnKeyRelease_PinStateChangedToInactive_ReturnTrue();
void OnKeyRelease_PinStateDidNotChange_ReturnFalse();
void OnKeyRelease_PinStateIsActive_ReturnFalse();
void OnLongPress_TimePassedIsNotGreaterThanLongPressDuration_ReturnFalse();
void OnLongPress_TimePassedIsGreaterThanLongPressDuration_ReturnTrue();
void OnLongPress_TimePassedIsEqualToLongPressDuration_ReturnTrue();
void ConfigurePinsForKeyMap_InvokesPinModeForEachKey();
void ConfigurePinsForKeyMap_CallsPinModeWithPinFromKeyMap();
void ConfigurePinsForKeyMap_SetsUpPinAsInputPullup();
void DebounceRead_UpdatesOldValueOfStateWithPreviousStateValue();
void DebounceRead_ReadsStateOfPin();
void DebounceRead_PinStateHasChanged_UpdatesLastDebounceTime();
void DebounceRead_PinStateHasNotChanged_DoesNotUpdateLastDebounceTime();
void DebounceRead_DebounceTimeExceededAndValueIsOutdated_UpdateStateValue();
void DebounceRead_DebounceTimeExceededAndValueIsOutdatedAndTheNewValueIsActive_UpdateTheTimeOfActivation();
void DebounceRead_ValueIsOutdatedButDebounceTimeIsNotExceeded_DoesNotUpdateStateValue();
void DebounceRead_DebounceTimeExceededAndTheValueIsActiveButValueIsNotOutdated_DoesNotUpdateTheTimeOfActivation();
void DebounceRead_OldPinStateIsUpdated();
void UpdatePinStatesForKeyMap_CallsDigitalReadForEachItem();
void UpdatePinStatesForKeyMap_CorrectlyParsesKeyPin();
void UpdatePinStatesForKeyMap_UpdatesStateForAllPins();
void UpdatePinStatesForKeyMap_KeymapUsesDatatypeKey_Works();
void UpdatePinStatesForKeyMap_KeymapUsesDatatypeSpecialKey_Works();
void NodeConstructor_NoArguments_InitializesWithADefaultObjectAsValueAndNextIsNullptr();
void NodeConstructor_WithArguments_InitializesValueAndNextWithPovidedArguments();
void LinkedListConstructor_NoArguments_HeadAndTailAreSetToNullptrAndLengthIsZero();
void LinkedListCopyConstructor_ItemsArePlacedInTheSameOrder();
void LinkedListCopyConstructor_MakesACopyOfAllItems();
void GetFirstNode_GetsFirstNode();
void GetSecondNode_GetsSecondNode();
void GetNodeInTheMiddleOfList_GetsNode();
void GetLastNodeByPassingInLengthMinusOne_GetsLastNode();
void TryToGetNodeOutOfRange_GetsNullptr();
void TryToGetNodeWithEmptyList_GetsNullptr();
void TryToGetNodeWithNegativeNumber_GetsNullptr();
void GetTwoDifferentNodes_AllNodesAreNotTheSame();
void GetFirstItemUsingSubscriptOperator_GetsItem();
void GetSecondItemUsingSubscriptOperator_GetsSecondItem();
void GetItemInTheMiddleOfListUsingSubscriptOperator_GetsItem();
void GetLastItemByPassingLengthMinusOneToSubscriptOperator_GetsLastItem();
void OutOfRangeInSubscriptOperator_GetsNullptr();
void UsingSubscriptOperatorWithEmptyList_GetsNullptr();
void UsingSubscriptOperatorWithNegativeNumber_GetsNullptr();
void UsingSubscriptOperator_AllItemsAreNotTheSame();
void AddItemToList_ListContainsItem();
void AddOneItemToList_ItemBecomesHead();
void AddOneItemToList_ItemBecomesTail();
void AddTwoItemsToList_FirstIsHeadSecondIsTail();
void AddMultipleItemsToList_FirstlyAddedIsHeadLastlyAddedIsTail();
void AddItem_LengthIncreasesByOne();
void InsertItemIntoEmptyList_ItemIsHead();
void InsertItemIntoEmptyList_ItemIsTail();
void InsertItemAtIndexZero_ItemIsHead();
void InsertItemAtLastIndex_ItemIsTail();
void InsertItemAtIndexThenGetItemFromIndex_ItemAtIndexIsTheInsertedItem();
void InsertItemIntoMiddleOfPopulatedList_AllItemsArePresent();
void InsertItemIntoEmptyListWithIndexOutOfRange_NothingIsAdded();
void InsertItemIntoPopulatedListWithIndexOutOfRange_NothingIsAdded();
void InsertItem_LengthIncreasesByOne();
void InsertMultipleItems_LengthIsSameAsAmountOfItems();
void InsertItemAtLastIndexUsingLength_ItemIsTail();
void TryToRemoveItemOfEmptyList_ReturnsFalse();
void TryToRemoveItemOutOfRange_ReturnsFalse();
void RemovesSpecificItemFromList_ReturnsCorrectItem();
void RemoveOnlyItemInList_ReturnsCorrectItem();
void RemoveOnlyItemInList_HeadIsNullptr();
void RemoveOnlyItemInList_TailIsNullptr();
void RemoveFirstItemOfListWithTwoItems_SecondItemIsNowHead();
void RemoveFirstItemOfListWithTwoItems_SecondItemIsStillTail();
void RemoveItemInTheMiddleOfList_ItemFollowingTheRemovedItemNowOccupiesTheRemovedItemsIndex();
void RemoveItemInTheMiddleOfList_TheRemovedItemIsNoLongerInTheListAtTheRemovedIndex();
void RemoveItemInMiddleOfList_FollowingItemTakesRemovedItemsPosition();
void RemoveLastItemInList_SecondLastItemIsNowTail();
void RemoveLastItemInList_NewTailsNextPointerIsNowNullptr();
void RemoveOnlyItemInList_LengthIsZero();
void RemoveItemInPopulatedList_LengthDecreasesByOne();
void RemoveAllItemsInList_LengthIsZero();
void ClearList_HeadIsNullptr();
void ClearList_TailIsNullptr();
void ClearList_LengthIsZero();
void CheckIsEmptyWhenListHasNoItems_ReturnsTrue();
void CheckIsEmptyWhenNotEmpty_ReturnsFalse();
void CheckIsEmptyAfterInsertingItem_ReturnsFalse();
void CheckIsEmptyAfterBecomingEmpty_ReturnsTrue();
void CheckIsEmptyAfterAddingMultipleItemsThenRemovingOne_ReturnsFalse();
void TestIfVectorTestsAreWorking_ShouldReturnDifferentValuesEachTime();
void TestIfVectorTestsAreWorking_ShouldReturnDifferentParametersEachTime();
void TestIfOverwriteReferenceVectorIsWorking_Works();
void TestIfOverwriteReferenceVectorResettingIsWorking_ResetsBetweenTests();
void TestIfOverwriteReferenceIsWorking_Works();
void TestIfOverwriteReferenceResettingIsWorking_ResetsBetweenTests();

void RunTests() 
{
	RUN_TEST(Controller_Constructor_ReadsSizeOfEEPROMAndSavesItToStorageSizeVariable);
	RUN_TEST(Controller_Constructor_CopiesProvidedKeymapsIntoClass);
	RUN_TEST(Controller_Constructor_AllocatesEnoughSpaceForPointers);
	RUN_TEST(Controller_Constructor_AmountOfFreeStorageIsEqualToTheStorageSize);
	RUN_TEST(CyclicEepromAdress_TakesInAnAdressThatExceedsTheEepromsSize_WrapsBackToTheBeginningOfTheEeprom);
	RUN_TEST(CyclicEepromAdress_AdressOvershootsEepromSizeWithOneStep_ReturnsTheFirstAdressOftheEeprom);
	RUN_TEST(CyclicEepromAdress_TakesInAnAdressThatExceedsTheEepromsSize_CalculatesTheNewAdressCorrectly);
	RUN_TEST(CyclicEepromAdress_AdressIsWithinEepromsSize_AdressIsUnchanged);
	RUN_TEST(RetrieveBareKeyboardKeysFromMemory_RetrievesFaultyData_DoesNotCrashAndReturnsFalse);
	RUN_TEST(RetrieveBareKeyboardKeysFromMemory_FindsPacketAndReturnsTheBareKeyboardKeysInside);
	RUN_TEST(RetrieveBareKeyboardKeysFromMemory_FindsDefectPacket_ReturnsFalse);
	RUN_TEST(RetrieveBareKeyboardKeysFromMemory_EepromHasDefectPacketFollowedByValidPacket_ReturnsKeysFromValidPacket);
	RUN_TEST(ConvertDataPacketToBareKeyboardKeys_RetrievesCorrectPacketWithFaultyPayload_DoesNotCrash);
	RUN_TEST(ConvertDataPacketToBareKeyboardKeys_SuccessfullyConvertsPacketIntoListOfBareKeyboardKeys);
	RUN_TEST(ParseBareKeyboardKeyArrayIntoKeymapList_PopulatesTheListWithTheGivenKeys);
	RUN_TEST(IsKeyValid_ThePinOfTheKeyIsPresentInTheDefaultKeymap_ReturnsTrue);
	RUN_TEST(IsKeyValid_ThePinOfTheKeyIsNotPresentInTheDefaultKeymap_ReturnsFalse);
	RUN_TEST(LoadKeymapsFromMemoryIntoList_CorrectlyLoadsKeymapIntoList);
	RUN_TEST(LoadKeymapsFromMemoryIntoList_LoadsKeymap_SetsEepromAdressToTheLoadedPacketsAdress);
	RUN_TEST(LoadKeymapsFromMemoryIntoList_LoadsKeymap_SetsNextFreeEepromAdressToAFreeAdressAfterTheEndOfTheLoadedPacket);
	RUN_TEST(LoadKeymapsFromMemoryIntoList_LoadsKeymap_SetsTheAmountOfFreeStorageToBeEqualToTheStorageSizeMinusTheSizeOfTheLoadedPacket);
	RUN_TEST(LoadKeymapsFromMemoryIntoList_FailsToLoadKeymap_DoesNotChangeAmountOfFreeStorage);
	RUN_TEST(LoadKeymapsFromMemoryIntoList_LoadsKeymapThatExceedsTheEepromsLastAdress_DoesNotUpdateNextPacketAdressWithAnAdressOutsideTheEeprom);
	RUN_TEST(LoadKeymapsFromMemoryIntoList_EepromHasDefectKeymaps_DoesNotLoadKeymaps);
	RUN_TEST(LoadKeymapsFromMemoryIntoList_EepromHasDefectKeymapsFollowedByValidKeymaps_LoadsTheValidKeymaps);
	RUN_TEST(WipeKeyboardEventBuffer_BufferOnlyContainsZeroes);
	RUN_TEST(SendKeyboardEvent_CallsSerialWriteWithTheCorrectBufferSize);
	RUN_TEST(SendKeyboardEvent_CallsSerialWriteWithTheCorrectBuffer);
	RUN_TEST(ChangeKeyMap_TheDefaultKeymapIsEquipped_isUsingDefaultKeymapIsAssignedToTrue);
	RUN_TEST(ChangeKeyMap_ACustomKeymapIsEquipped_isUsingDefaultKeymapIsAssignedFalse);
	RUN_TEST(ChangeKeyMap_ACustomKeymapWithSimilarButNotTheSameSettingsAsDefaultKeymapIsEquipped_isUsingDefaultKeymapIsAssignedFalse);
	RUN_TEST(ChangeKeyMap_DefaultKeymapIsSelectedAndWeAreEquippingACustomKeymap_CurrentKeymapNowContainsKeysOfCustomKeymap);
	RUN_TEST(ChangeKeyMap_EmptiesBufferAndSendsItAsAKeyReleaseEventForAllKeys);
	RUN_TEST(ChangeKeyMap_ConfiguresThePinsOfTheProvidedKeymap);
	RUN_TEST(CycleKeyMap_TheDefaultKeymapIsCurrentlyEquipped_EquipsTheFirstKeymapInTheList);
	RUN_TEST(CycleKeyMap_TheDefaultKeymapIsCurrentlyEquippedAndWeCycleTwice_EquipsTheSecondKeymapInTheList);
	RUN_TEST(CycleKeyMap_TheDefaultKeymapIsCurrentlyEquippedAndWeOnlyhaveTwoCustomKeymapsAndWeCycleThreeTimes_WhenWeCycleOffTheLastCustomKeymapItLoopsBackToTheFirstKeymapInTheList);
	RUN_TEST(SaveKeyMapsToMemory_PutsDownKeysAsBareKeyboardKeyArrayIntoEEPROM);
	RUN_TEST(SaveKeyMapsToMemory_Succeeds_ReturnsTrue);
	RUN_TEST(SaveKeyMapsToMemory_UpdatesCurrentPacketAdressWithTheAdressOfTheSavedPacket);
	RUN_TEST(SaveKeyMapsToMemory_UpdatesNextPacketAdressWithAFreeAdress);
	RUN_TEST(SaveKeyMapsToMemory_SavesKeymaps_SetsTheAmountOfFreeStorageToBeEqualToTheStorageSizeMinusTheSizeOfTheSavedPacket);
	RUN_TEST(SaveKeyMapsToMemory_FailsToSavePacket_DoesNotChangeAmountOfFreeStorage);
	RUN_TEST(SaveKeyMapsToMemory_SavedPacketExceedsTheLastAdressOfTheEeprom_DoesNotSetNextPacketAdressToAnAdressOutsideTheEeprom);
	RUN_TEST(SaveKeyMapsToMemory_PacketIsSavedAtTheNextPacketAdress);
	RUN_TEST(SaveKeyMapsToMemory_PacketIsSavedSuccessfully_DeactivatesOldPacket);
	RUN_TEST(SaveKeyMapsToMemory_CurrentPacketAdressAndNextPacketAdressAreTheSame_SuccessfullySavesPacket_DoesNotDeactivateTheSavedPacket);
	RUN_TEST(SaveKeyMapsToMemory_FailedToSavePacket_DoesNotDeactivateOldPacket);
	RUN_TEST(SaveKeyMapsToMemory_TheFunctionFailsBecauseTheSavedPacketCanNotBeRead_ReturnsFalse);
	RUN_TEST(ToggleEditMode_CurrentKeymapHasBeenEdited_UpdatesTheEquippedCustomKeymapWithTheValuesPresentInCurrentKeymap);
	RUN_TEST(SaveControllerSettings_CurrentKeymapHasBeenEdited_UpdatesTheEquippedCustomKeymapWithTheValuesPresentInCurrentKeymap);
	RUN_TEST(UpdateCurrentCustomKeymap_CurrentKeymapHasBeenEdited_UpdatesTheEquippedCustomKeymapWithTheValuesPresentInCurrentKeymap);
	RUN_TEST(UpdateCurrentCustomKeymap_CurrentKeymapHasBeenEditedAndTheSecondCustomKeymapIsSelected_UpdatesTheSelectedCustomKeymap);
	RUN_TEST(UpdateCurrentCustomKeymap_CurrentKeymapHasBeenEditedAndTheSecondCustomKeymapIsSelected_DoesNotChangeTheOtherKeymaps);
	RUN_TEST(CreateNewKeymap_SuccessfullyCreatesAKeymapInCustomKeymaps);
	RUN_TEST(CreateNewKeymap_SuccessfullyCreatesAKeymap_ReturnsTrue);
	RUN_TEST(CreateNewKeymap_SuccessfullyCreatesAKeymap_KeymapIsAddedToTheEndOfTheCustomKeymapList);
	RUN_TEST(CreateNewKeymap_SuccessfullyCreatesAKeymap_NewKeymapInheritsPinsFromDefaultKeymap);
	RUN_TEST(CreateNewKeymap_SuccessfullyCreatesAKeymap_KeycodesOnNewKeymapsDefaultTo4);
	RUN_TEST(CreateNewKeymap_SuccessfullyCreatesAKeymap_EquipsTheNewKeymap);
	RUN_TEST(CreateNewKeymap_WeHaveEnoughFreeMemory_CreatesKeymapAndReturnsTrue);
	RUN_TEST(CreateNewKeymap_DoesNotHaveEnoughMemoryLeft_DoesNotCreateAKeymapAndReturnsFalse);
	RUN_TEST(Helper_ReadDataPacketOnEEPROM_PrepareToReturnPacket_ParsePacketFromEepromSuccessfullyReturnsCorrectPacket);
	RUN_TEST(Helper_ReadDataPacketOnEEPROM_PrepareToReturnPacket_SetEepromSizeByHandToFitThePacket_ParsePacketFromEepromSuccessfullyReturnsCorrectPacket);
	RUN_TEST(Helper_ReadDataPacketOnEEPROM_PrepareToReturnPacket_UsingHighAdress_EepromLengthIsSetToFitPacket);
	RUN_TEST(Helper_ReadDataPacketOnEEPROM_PrepareToReturnPacket_SetEepromSizeByHandToNotFitThePacket_ReadDataPacketOnEEPROMFails);
	RUN_TEST(Helper_ReadDataPacketOnEEPROM_PrepareToReturnPacket_ParsePacketFromEepromRecievesInactiveFlag);
	RUN_TEST(Helper_SaveDataPacketToEEPROM_PreparesEepromSizeAndPrepareToReturnPacket_SaveDataPacketToEEPROMReturnsTrueAndReturnsCorrectPacketSize);
	RUN_TEST(Helper_SaveDataPacketToEEPROM_PreparesEepromSizeAndPrepareToReturnPacket_SetEepromSizeByHandToNotFitPacket_ReturnsFalse);
	RUN_TEST(Helper_SaveDataPacketToEEPROM_PreparesEepromSizeAndPrepareToReturnPacket_SetEepromSizeByHandToFitPacket_ReturnsTrue);
	RUN_TEST(Helper_SaveDataPacketToEEPROM_PreparesEepromSizeAndPrepareToReturnPacket_WeProvideNoEepromSize_SetsEepromSizeAutomaticallyToFitOurPacket);
	RUN_TEST(Helper_SaveDataPacketToEEPROM_PreparesEepromSizeAndPrepareToReturnPacket_UsingHighAdress_EepromLengthIsSetToFitPacket);
	RUN_TEST(Helper_CalculateSizeOfPacketOnEEPROM_ReturnsCorrectSizeOfPacket);
	RUN_TEST(DataPacket_Constructor_NoArguments_AllocatesSpaceForPayload);
	RUN_TEST(DataPacket_Constructor_WithArguments_CopiesDataIntoPayload);
	RUN_TEST(DataPacket_Constructor_WithArguments_SetsUpPacketCorrectly);
	RUN_TEST(DataPacket_CopyConstructor_CopiesValuesAndPayload);
	RUN_TEST(DataPacket_CopyConstructor_PayloadIsCopiedAndIndependent);
	RUN_TEST(DataToPacket_TakesInDataOfTypeT_ConvertsItCorrectlyIntoADataPacket);
	RUN_TEST(DataToPacket_TakesInDataOfTypeBool_CanHandleDifferentTypes);
	RUN_TEST(DataPacket_ByDefault_StxIsTwo);
	RUN_TEST(DataPacket_ByDefault_EtxIsThree);
	RUN_TEST(DataPacket_ByDefault_ActiveIsTrue);
	RUN_TEST(CalculateCRC_UsesAlgorithCRC32);
	RUN_TEST(CyclicAdress_TakesInAnAdressThatExceedsTheBufferSize_WrapsBackToTheBeginningOfTheBuffer);
	RUN_TEST(CyclicAdress_AdressOvershootsLastBufferAdressWithOneStep_ReturnsTheFirstAdressOftheBuffer);
	RUN_TEST(CyclicAdress_TakesInAnAdressThatExceedsTheLastAdressOfTheBuffer_CalculatesTheNewAdressCorrectly);
	RUN_TEST(CyclicAdress_OvershootsWholeBufferMultipleTimes_ReturnsAdressWithinBuffersSize);
	RUN_TEST(CyclicAdress_CalculatesNewAdressDependingOnBufferSize_ReturnsCorrectAdress);
	RUN_TEST(CyclicAdress_ProvidedAdressIsWithinBuffersSize_AdressIsUnchanged);
	RUN_TEST(CyclicAdress_BufferSizeIsZero_ReturnsZero);
	RUN_TEST(SizeOfSerializedDataPacket_ReturnsTheAmountOfBytesTheDataPacketWillOccupyOnMemory);
	RUN_TEST(SizeOfSerializedDataPacket_CalculatesSizeDependingOnTheSizeOfThePayload);
	RUN_TEST(SizeOfSerializedDataPacket_MustReturnTheSameSizeAsSaveDataPacketPacketToEEPROM);
	RUN_TEST(SaveDataPacketToEEPROM_SavesStxToFirstGivenAdress);
	RUN_TEST(SaveDataPacketToEEPROM_EtxIsPutDownAtTheEndOfThePacket);
	RUN_TEST(SaveDataPacketToEEPROM_PacketIsCorrectlyPutDown);
	RUN_TEST(SaveDataPacketToEEPROM_PacketWillExceedEndOfEEPROM_ReturnsCorrectPacketSize);
	RUN_TEST(SaveDataPacketToEEPROM_PacketWillExceedEndOfEEPROM_SplitsPacketBetweenEndAndStartOfEEPROM);
	RUN_TEST(SaveDataPacketToEEPROM_SplitsPacketOnPayload_PutsDownPayloadOnCorrectAdresses);
	RUN_TEST(SaveDataPacketToEEPROM_PacketIsSavedButEepromFailsToReadTheData_ReturnsFalse);
	RUN_TEST(SaveDataPacketToEEPROM_AdaptsSizeOfPacketToFitData);
	RUN_TEST(SaveDataPacketToEEPROM_AdressIsOutsideOfEEPROMsRange_ReturnsFalse);
	RUN_TEST(SaveDataPacketToEEPROM_AdressIsOutsideOfEEPROMsRange_DoesNotWriteAnythingToEEPROM);
	RUN_TEST(SaveDataPacketToEEPROM_PacketIsTooBigForEEPROM_DoesNotWriteToMemoryAndReturnsFalse);
	RUN_TEST(SaveDataPacketToEEPROM_PacketFitsOnEEPROM_ReturnsTrue);
	RUN_TEST(ReadDataPacketOnEEPROM_DataPacketDoesNotNeedToBeManuallyAllocatedBeforePassedToFunciton_DoesNotCrash);
	RUN_TEST(ReadDataPacketOnEEPROM_ReturnsCorrectPacket);
	RUN_TEST(ReadDataPacketOnEEPROM_PacketIsSplitBetweenEndAndStartOfEEPROM_ReturnsCorrectPacketSize);
	RUN_TEST(ReadDataPacketOnEEPROM_PacketIsSplitBetweenEndAndStartOfEEPROM_SuccessfullyReadsPacket);
	RUN_TEST(ReadDataPacketOnEEPROM_PacketsPayloadIsSplitBetweenEndAndStartOfEEPROM_SuccessfullyReadsPayload);
	RUN_TEST(ReadDataPacketOnEEPROM_ReturnsFalseWhenAValidPacketIsNotActive);
	RUN_TEST(ReadDataPacketOnEEPROM_ReturnsTrueWhenAValidPacketIsActive);
	RUN_TEST(ReadDataPacketOnEEPROM_EepromReturnsFaultyData_ReturnsFalse);
	RUN_TEST(ReadDataPacketOnEEPROM_AdressIsOutOfEEPROMsRange_ReturnsFalse);
	RUN_TEST(IsPacketActive_PacketsActiveFlagIsOne_ReturnsTrue);
	RUN_TEST(IsPacketActive_PacketsActiveFlagIsZero_ReturnsFalse);
	RUN_TEST(IsPacketActive_PacketsActiveFlagIsNotOne_ReturnsFalse);
	RUN_TEST(DeactivatePacket_OverritesCorrectByteWithADeactivatedFlag);
	RUN_TEST(DeactivatePacket_ReadsStxPayloadLengthAndEtxFromTheRightPlaces);
	RUN_TEST(DeactivatePacket_DeactivatesPacketSuccessfully_ReturnsTrue);
	RUN_TEST(DeactivatePacket_StxIsAtTheLastAdressAndActiveFlagIsOnTheFirstAdressOfEeprom_DeactivatesTheCorrectAdress);
	RUN_TEST(DeactivatePacket_AdressDoesNotPointToStx_ReturnsFalse);
	RUN_TEST(DeactivatePacket_AdressDoesNotPointToStx_DoesNotWriteToEEPROM);
	RUN_TEST(DeactivatePacket_AdressIsOutOfRangeOfEeprom_ReturnsFalseAndDoesNotWriteToEeprom);
	RUN_TEST(DeactivatePacket_AdressPointsToStxButCantFindEtxOfPacket_ReturnsFalse);
	RUN_TEST(DeactivatePacket_AdressPointsToStxButCantFindEtxOfPacket_DoesNotWriteToEEPROM);
	RUN_TEST(FindFirstDataPacketOnEEPROM_TakesInAStartAdress_BeginsLookingAtTheGivenAdress);
	RUN_TEST(FindFirstDataPacketOnEEPROM_FindsPacket_ReturnsTrue);
	RUN_TEST(FindFirstDataPacketOnEEPROM_PacketIsPresentAfterGarbageData_FindsPacket);
	RUN_TEST(FindFirstDataPacketOnEEPROM_PacketIsPresentAfterGarbageData_FindsPacketOnCorrectAdress);
	RUN_TEST(FindFirstDataPacketOnEEPROM_FindsPacket_ReturnsCorrectPacketSize);
	RUN_TEST(FindFirstDataPacketOnEEPROM_NoPacketIsPresent_LooksAtEveryPositionOfTheEeprom);
	RUN_TEST(FindFirstDataPacketOnEEPROM_NoPacketIsPresent_ReturnsFalse);
	RUN_TEST(FindFirstDataPacketOnEEPROM_PacketIsPresentOnEEPROMButStartAdressIsOutOfRange_ReturnsFalse);
	RUN_TEST(DeactivateAllPacketsOnEEPROM_OnePacketIsPresent_OverwritesPacketWithADeactivatedFlag);
	RUN_TEST(DeactivateAllPacketsOnEEPROM_OverwritesPacketWithADeactivatedFlag_ReturnsTrue);
	RUN_TEST(DeactivateAllPacketsOnEEPROM_ADeactivatedPacketIsPresent_DoesNotOverwritePacket);
	RUN_TEST(DeactivateAllPacketsOnEEPROM_OnePacketIsPresentAfterGarbageData_OverwritesCorrectPositionWithADeactivatedFlag);
	RUN_TEST(DeactivateAllPacketsOnEEPROM_MultiplePacketsArePresent_OverwritesAllPacketsWithADeactivatedFlag);
	RUN_TEST(DeactivateAllPacketsOnEEPROM_NoPacketIsPresent_DoesNotWriteToEEPROM);
	RUN_TEST(DeactivateAllPacketsOnEEPROM_NoPacketIsPresent_ReturnsFalse);
	RUN_TEST(EditMode_Constructor_SetsCorrectValues);
	RUN_TEST(EditMode_Initialized_NotEnabledByDefault);
	RUN_TEST(Toggle_WhenDisabled_BecomesEnabled);
	RUN_TEST(Toggle_WhenEnabled_BecomesDisabled);
	RUN_TEST(Reset_SelectedKeyNotReset_BecomesNullptr);
	RUN_TEST(Reset_KeysPressedNotReset_BecomesZero);
	RUN_TEST(Reset_InputKeyCodeNotReset_BecomesZero);
	RUN_TEST(Reset_ShouldAddValueNotReset_BecomesFalse);
	RUN_TEST(Reset_BlinkValuesNotReset_BecomesResetToInitialValues);
	RUN_TEST(Reset_BuiltinLedIsOn_IsTurnedOff);
	RUN_TEST(CopyKeyMapToTemporary_TempCopyIsOverwrittenWithTheValuesOfTheProvidedKeyMap);
	RUN_TEST(RestoreKeyMapFromTemporaryCopy_ProvidedKeyMapIsRestoredToStateWhenCopyKeyMapToTemporaryWasCalled);
	RUN_TEST(RestoreKeyMapFromTemporaryCopy_ResetEditMode);
	RUN_TEST(RegisterKeyPress_AddsOneToKeysPressed);
	RUN_TEST(RegisterKeyPress_IfNoKeyIsSelected_SelectProvidedKey);
	RUN_TEST(RegisterKeyPress_IfKeyHasAlreadyBeenSelected_DoNotUpdateSelectedKey);
	RUN_TEST(RegisterKeyPress_TheFirstKeyIsBeingPressed_ShouldNotPrepareToAddValueToKey);
	RUN_TEST(RegisterKeyPress_FirstKeyHasAlreadyBeenRegistered_PrepareToAddValueToTheKey);
	RUN_TEST(RegisterKeyRelease_KeysPressedIsDecreasedByOne);
	RUN_TEST(RegisterKeyRelease_SelectedKeyIsNullptrAndOneKeyIsPressed_PreventsAccessingSelectedKeyWhenNullptr);
	RUN_TEST(RegisterKeyRelease_ShouldAddValueIsTrue_InputKeyCodeIsChanged);
	RUN_TEST(RegisterKeyRelease_ShouldAddValueIsTrue_CorrectValueIsAddedToInputKeyCode);
	RUN_TEST(RegisterKeyRelease_TwoKeysWerePressedBeforeReleasing_ProvidesExponentZeroAndBaseTenToPow);
	RUN_TEST(RegisterKeyRelease_ThreeKeysWerePressedBeforeReleasing_ProvidesExponentOneAndBaseTenToPow);
	RUN_TEST(RegisterKeyRelease_FourKeysWerePressedBeforeReleasing_ProvidesExponentTwoAndBaseTenToPow);
	RUN_TEST(RegisterKeyRelease_AfterAddingValue_PreventNextKeyReleaseFromAddingValueToInputKeyCode);
	RUN_TEST(RegisterKeyRelease_LastKeyIsReleased_AppliesInputKeyCodeToKeyBeingEdited);
	RUN_TEST(RegisterKeyRelease_LastKeyIsReleased_ResetsUsedVariables);
	RUN_TEST(RegisterKeyRelease_ShouldNotAddValue_InputKeyCodeRemainsTheSame);
	RUN_TEST(EditModeLoop_KeyHasNotBeenChanged_DoesNotDoAnything);
	RUN_TEST(EditModeLoop_KeyBecamePressed_RegistersKeyPress);
	RUN_TEST(EditModeLoop_TwoKeysBecamePressed_RegistersTwoKeyPresses);
	RUN_TEST(EditModeLoop_KeyBecameReleased_RegistersKeyRelease);
	RUN_TEST(EditModeLoop_TwoKeysBecameReleased_RegistersTwoKeyReleases);
	RUN_TEST(EditModeLoop_WhenIdle_SignalEditMode);
	RUN_TEST(KeyConstructor_NoArguments_IntializesPinAndKeycodeWithZeroAndIPinStateWithDefaultValues);
	RUN_TEST(KeyConstructor_WithArguments_IntializesPinAndKeycodeCorrectly);
	RUN_TEST(SpecialKeyConstructor_NoArguments_IntializesPinAndFunctionCorrectly);
	RUN_TEST(SpecialKeyConstructor_WithArguments_IntializesPinAndFunctionCorrectly);
	RUN_TEST(BareKeyboardKeyConstructor_NoArguments_IntializesPinAndKeycodeWithZero);
	RUN_TEST(BareKeyboardKeyConstructor_WithArguments_IntializesPinAndKeycodeCorrectly);
	RUN_TEST(SpecialKeyEqualityOperator_PinAndFunctionAreTheSameBetweenObjects_ReturnsTrue);
	RUN_TEST(SpecialKeyEqualityOperator_PinDifferBetweenObjects_ReturnsFalse);
	RUN_TEST(SpecialKeyEqualityOperator_FunctionDifferBetweenObjects_ReturnsFalse);
	RUN_TEST(SpecialKeyEqualityOperator_PinAndFunctionAreTheSameBetweenObjectsButStateIsDifferent_IgnoresStateAndReturnsTrue);
	RUN_TEST(SpecialKeyNotEqualityOperator_PinAndFunctionDifferBetweenObjects_ReturnsOppositeOfEqualityOperator);
	RUN_TEST(SpecialKeyNotEqualityOperator_PinAndFunctionAreTheSameBetweenObjects_ReturnsOppositeOfEqualityOperator);
	RUN_TEST(BareKeyboardKeyEqualityOperator_PinAndKeycodeAreTheSameBetweenObjects_ReturnsTrue);
	RUN_TEST(BareKeyboardKeyEqualityOperator_PinDifferBetweenObjects_ReturnsFalse);
	RUN_TEST(BareKeyboardKeyEqualityOperator_KeycodeDifferBetweenObjects_ReturnsFalse);
	RUN_TEST(BareKeyboardKeyNotEqualityOperator_PinAndKeycodeDifferBetweenObjects_ReturnsOppositeOfEqualityOperator);
	RUN_TEST(BareKeyboardKeyNotEqualityOperator_PinAndKeycodeAreTheSameBetweenObjects_ReturnsOppositeOfEqualityOperator);
	RUN_TEST(ConfigurePinForKey_IKeyIsPassedToPinMode);
	RUN_TEST(ConfigurePinForKeyOfTypeKey_IsCorrectlyParsedToIKey);
	RUN_TEST(ConfigurePinForKeyOfTypeSpecialKey_IsCorrectlyParsedToIKey);
	RUN_TEST(ConfigurePinForKey_ConfiguresPinAsInputPullup);
	RUN_TEST(ConfigurePinForKey_CallsPinModeOnce);
	RUN_TEST(OnKeyPress_PinStateWentFromInactiveToActive_ReturnsTrue);
	RUN_TEST(OnKeyPress_PinStateValueDidNotChange_ReturnsFalse);
	RUN_TEST(OnKeyPress_PinStateIsInactive_ReturnFalse);
	RUN_TEST(OnKeyRelease_PinStateChangedToInactive_ReturnTrue);
	RUN_TEST(OnKeyRelease_PinStateDidNotChange_ReturnFalse);
	RUN_TEST(OnKeyRelease_PinStateIsActive_ReturnFalse);
	RUN_TEST(OnLongPress_TimePassedIsNotGreaterThanLongPressDuration_ReturnFalse);
	RUN_TEST(OnLongPress_TimePassedIsGreaterThanLongPressDuration_ReturnTrue);
	RUN_TEST(OnLongPress_TimePassedIsEqualToLongPressDuration_ReturnTrue);
	RUN_TEST(ConfigurePinsForKeyMap_InvokesPinModeForEachKey);
	RUN_TEST(ConfigurePinsForKeyMap_CallsPinModeWithPinFromKeyMap);
	RUN_TEST(ConfigurePinsForKeyMap_SetsUpPinAsInputPullup);
	RUN_TEST(DebounceRead_UpdatesOldValueOfStateWithPreviousStateValue);
	RUN_TEST(DebounceRead_ReadsStateOfPin);
	RUN_TEST(DebounceRead_PinStateHasChanged_UpdatesLastDebounceTime);
	RUN_TEST(DebounceRead_PinStateHasNotChanged_DoesNotUpdateLastDebounceTime);
	RUN_TEST(DebounceRead_DebounceTimeExceededAndValueIsOutdated_UpdateStateValue);
	RUN_TEST(DebounceRead_DebounceTimeExceededAndValueIsOutdatedAndTheNewValueIsActive_UpdateTheTimeOfActivation);
	RUN_TEST(DebounceRead_ValueIsOutdatedButDebounceTimeIsNotExceeded_DoesNotUpdateStateValue);
	RUN_TEST(DebounceRead_DebounceTimeExceededAndTheValueIsActiveButValueIsNotOutdated_DoesNotUpdateTheTimeOfActivation);
	RUN_TEST(DebounceRead_OldPinStateIsUpdated);
	RUN_TEST(UpdatePinStatesForKeyMap_CallsDigitalReadForEachItem);
	RUN_TEST(UpdatePinStatesForKeyMap_CorrectlyParsesKeyPin);
	RUN_TEST(UpdatePinStatesForKeyMap_UpdatesStateForAllPins);
	RUN_TEST(UpdatePinStatesForKeyMap_KeymapUsesDatatypeKey_Works);
	RUN_TEST(UpdatePinStatesForKeyMap_KeymapUsesDatatypeSpecialKey_Works);
	RUN_TEST(NodeConstructor_NoArguments_InitializesWithADefaultObjectAsValueAndNextIsNullptr);
	RUN_TEST(NodeConstructor_WithArguments_InitializesValueAndNextWithPovidedArguments);
	RUN_TEST(LinkedListConstructor_NoArguments_HeadAndTailAreSetToNullptrAndLengthIsZero);
	RUN_TEST(LinkedListCopyConstructor_ItemsArePlacedInTheSameOrder);
	RUN_TEST(LinkedListCopyConstructor_MakesACopyOfAllItems);
	RUN_TEST(GetFirstNode_GetsFirstNode);
	RUN_TEST(GetSecondNode_GetsSecondNode);
	RUN_TEST(GetNodeInTheMiddleOfList_GetsNode);
	RUN_TEST(GetLastNodeByPassingInLengthMinusOne_GetsLastNode);
	RUN_TEST(TryToGetNodeOutOfRange_GetsNullptr);
	RUN_TEST(TryToGetNodeWithEmptyList_GetsNullptr);
	RUN_TEST(TryToGetNodeWithNegativeNumber_GetsNullptr);
	RUN_TEST(GetTwoDifferentNodes_AllNodesAreNotTheSame);
	RUN_TEST(GetFirstItemUsingSubscriptOperator_GetsItem);
	RUN_TEST(GetSecondItemUsingSubscriptOperator_GetsSecondItem);
	RUN_TEST(GetItemInTheMiddleOfListUsingSubscriptOperator_GetsItem);
	RUN_TEST(GetLastItemByPassingLengthMinusOneToSubscriptOperator_GetsLastItem);
	RUN_TEST(OutOfRangeInSubscriptOperator_GetsNullptr);
	RUN_TEST(UsingSubscriptOperatorWithEmptyList_GetsNullptr);
	RUN_TEST(UsingSubscriptOperatorWithNegativeNumber_GetsNullptr);
	RUN_TEST(UsingSubscriptOperator_AllItemsAreNotTheSame);
	RUN_TEST(AddItemToList_ListContainsItem);
	RUN_TEST(AddOneItemToList_ItemBecomesHead);
	RUN_TEST(AddOneItemToList_ItemBecomesTail);
	RUN_TEST(AddTwoItemsToList_FirstIsHeadSecondIsTail);
	RUN_TEST(AddMultipleItemsToList_FirstlyAddedIsHeadLastlyAddedIsTail);
	RUN_TEST(AddItem_LengthIncreasesByOne);
	RUN_TEST(InsertItemIntoEmptyList_ItemIsHead);
	RUN_TEST(InsertItemIntoEmptyList_ItemIsTail);
	RUN_TEST(InsertItemAtIndexZero_ItemIsHead);
	RUN_TEST(InsertItemAtLastIndex_ItemIsTail);
	RUN_TEST(InsertItemAtIndexThenGetItemFromIndex_ItemAtIndexIsTheInsertedItem);
	RUN_TEST(InsertItemIntoMiddleOfPopulatedList_AllItemsArePresent);
	RUN_TEST(InsertItemIntoEmptyListWithIndexOutOfRange_NothingIsAdded);
	RUN_TEST(InsertItemIntoPopulatedListWithIndexOutOfRange_NothingIsAdded);
	RUN_TEST(InsertItem_LengthIncreasesByOne);
	RUN_TEST(InsertMultipleItems_LengthIsSameAsAmountOfItems);
	RUN_TEST(InsertItemAtLastIndexUsingLength_ItemIsTail);
	RUN_TEST(TryToRemoveItemOfEmptyList_ReturnsFalse);
	RUN_TEST(TryToRemoveItemOutOfRange_ReturnsFalse);
	RUN_TEST(RemovesSpecificItemFromList_ReturnsCorrectItem);
	RUN_TEST(RemoveOnlyItemInList_ReturnsCorrectItem);
	RUN_TEST(RemoveOnlyItemInList_HeadIsNullptr);
	RUN_TEST(RemoveOnlyItemInList_TailIsNullptr);
	RUN_TEST(RemoveFirstItemOfListWithTwoItems_SecondItemIsNowHead);
	RUN_TEST(RemoveFirstItemOfListWithTwoItems_SecondItemIsStillTail);
	RUN_TEST(RemoveItemInTheMiddleOfList_ItemFollowingTheRemovedItemNowOccupiesTheRemovedItemsIndex);
	RUN_TEST(RemoveItemInTheMiddleOfList_TheRemovedItemIsNoLongerInTheListAtTheRemovedIndex);
	RUN_TEST(RemoveItemInMiddleOfList_FollowingItemTakesRemovedItemsPosition);
	RUN_TEST(RemoveLastItemInList_SecondLastItemIsNowTail);
	RUN_TEST(RemoveLastItemInList_NewTailsNextPointerIsNowNullptr);
	RUN_TEST(RemoveOnlyItemInList_LengthIsZero);
	RUN_TEST(RemoveItemInPopulatedList_LengthDecreasesByOne);
	RUN_TEST(RemoveAllItemsInList_LengthIsZero);
	RUN_TEST(ClearList_HeadIsNullptr);
	RUN_TEST(ClearList_TailIsNullptr);
	RUN_TEST(ClearList_LengthIsZero);
	RUN_TEST(CheckIsEmptyWhenListHasNoItems_ReturnsTrue);
	RUN_TEST(CheckIsEmptyWhenNotEmpty_ReturnsFalse);
	RUN_TEST(CheckIsEmptyAfterInsertingItem_ReturnsFalse);
	RUN_TEST(CheckIsEmptyAfterBecomingEmpty_ReturnsTrue);
	RUN_TEST(CheckIsEmptyAfterAddingMultipleItemsThenRemovingOne_ReturnsFalse);
	RUN_TEST(TestIfVectorTestsAreWorking_ShouldReturnDifferentValuesEachTime);
	RUN_TEST(TestIfVectorTestsAreWorking_ShouldReturnDifferentParametersEachTime);
	RUN_TEST(TestIfOverwriteReferenceVectorIsWorking_Works);
	RUN_TEST(TestIfOverwriteReferenceVectorResettingIsWorking_ResetsBetweenTests);
	RUN_TEST(TestIfOverwriteReferenceIsWorking_Works);
	RUN_TEST(TestIfOverwriteReferenceResettingIsWorking_ResetsBetweenTests);
}

